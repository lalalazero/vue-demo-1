# vue上手笔记

## 第一个 vue 实例

```
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script>
	var app = new Vue({
		el: '#app', // 挂载到id为app的dom元素上
		data: {
			apple: 'apple',
			count: 0,
		},
		mounted: {
			// this 指向 vue 实例
			console.log(this.apple)
		},
		beforeDestory: {
		}
	})
	app.#el // 访问 vue 实例的el属性
	app.apple // 访问 vue 实例的 apple 属性
</script>
```

## 过滤器、指令和事件语法糖

1. 过滤器 

	管道符 | 
	
	过滤器串联： | filter1(arg1, arg2) | filter2..
	

2. 指令

	v-text: 渲染文本

	v-html: 渲染html

	v-bind: 动态绑定属性
	
	v-on: 监听 DOM 事件

3. 事件语法糖
	
	v-bind 的语法糖 :
	
	v-on 的语法糖 @

## 计算属性
1. 何时用？

	`{{ }}` 文本插值可以写一行表达式，但是如果需要大量计算的时候，一行表达式放不下或者写法丑陋，这时应该利用计算属性。
	
	```
	data:{
		firstname: 'san',
		lastname: 'zhang',
		text: '123,456,789',
	},
	computed: {
		reverseText:function(){
			return this.text.split(',').reverse().join(',')
		}
	}
	```
2. 小技巧
	
	i. 计算属性可以依赖其他计算属性
	
	ii. 计算属性可以依赖多个 vue 实例的数据
	
3. getter 和 setter
	
	```
	computed: {
		// 默认 getter 写法
      reverseText: function(){
        return this.text.split(',').reverse().join(',') + ' / ' + app2.msg
      },
      // 重写 get,set 方法
      fullName: {
        get: function(){
          return this.firstname + ' , ' + this.lastname
        },
        set: function(newName){
          console.log('set fullName 被调用了')
          this.firstname = newName.split(',')[0]
          this.lastname = newName.split(',')[1]
        }
      }
    }
	```
4. 缓存问题
	
	所有能用计算属性得到的数据，都可以用 methods 来做，计算属性和 methods 的重要区别是：计算属性是有缓存的。比如页面上 `{{ fullname }}` 是计算属性，只要 `fullname` 相关的数据不更新，计算属性就不会更新，不需要重新渲染页面。如果是 `{{ getFullname() }}` 方法，当 `data` 中的其他数据更新，造成页面重新渲染的时候，那么 `getFullname` 也会重新执行。
	
	```
	// 当 count 渲染在页面上，并且更新的时候导致页面的重新渲染，这时 getFullname 方法也会再次执行，但是计算属性的 fullname 因为有缓存，只有用到的数据更新了才会更新
	data: {
		this.firstname: 'san',
		this.lastname: 'zhang',
		this.count: 0,
	},
	methods: {
		getFullname: function(){
			return this.firstname + this.lastname
		}
	},
	computed: {
		fullname: function(){
			return this.firstname + this.lastname
		}
	}
	```
	

## v-bind 绑定 class
0. 变量语法

    `v-bind:class='classVariable'`
    `data:{ classVariable: 'some-class-name'}`

1. 对象语法
	
	`v-bind:class={class1: boolean1, class2: boolean2}`
   
   ```
   <div v-bind:class='{background: isback, border: isborder}'></div>
   
   var app = new Vue({
   		el: '#app',
   		data: {
   			isback: true,
   			isborder: true,
   		}
   })
   
   ```
   当逻辑复杂的时候可以用计算属性返回对象

2. 数组语法
	
	`v-bind:class=[class1, class2, 'class3']`
	
3. 数组和对象混用

	`v-bind:class=[{'active': isActive} ,'error']`
	

## v-bind 绑定 style，内联样式

1. 对象语法

    `v-bind:style="{'color': color, 'fontSize': fontSize+'px'}"`

    属性要用驼峰命名

    ```
    data: {
        color: 'red',
        fontSize: 16,
    }
    ```

2. 数组语法(用的不多)


## vue 的内置指令
1. v-cloak  

    解决初始化慢导致页面闪动，常用 `display:none` 结合使用

2. v-once 元素只渲染一次

3. 条件渲染.  

    `v-if` 
    `v-else`
    `v-else-if`
    `v-show` 

    `v-if` 的弊端： 在渲染的时候会尽可能的复用已有的元素，只渲染变化的部分，因此可能会出现不想要的情况。为了不复用元素，可以给元素加`key`属性。
    
    `v-if` 和 `v-show` 的比较: `v-if` 不满足条件的时候，dom 元素会被移除。`v-show`渲染之后 dom 元素会一直存在，如果不满足条件，是通过`display:none`隐藏的。

4. v-for 
	
	- 遍历数组对象
	
	`v-for='value in arr'`  `v-for='(value,index) in arr'`
	
	- 遍历对象属性
	
	`v-for='value in obj'`  `v-for='(value, key, index) in obj'`

	- vue 可以检测到的数组改变方法
	
	`pop push shift unshift splice sort reverse`
	
	- vue 检测不到的数组改变情况
	
	修改数组指定项 `arr[1] = 'text'`，改用 `Vue.set(app.arr, 1, 'text')`
	
	修改数组长度 `arr.length = 10`
	
5. 事件

    `.stop` 阻止进一步冒泡

    `.prevent` 阻止默认事件

    `.self` 事件发生是自己 (`target === currentTarget`)

    `once` 事件只执行一次

    绑定事件监听的时候，不加括号的话传递的第一个参数是原生事件对象 event

    `<button @click='handle'>click</button>`

    `<button @click='handle2("hello")>click</button>`

    ```
    methods: {
        handle: function(event){
            console.log(event)
        },
        handle2: function(str){
            console.log(str) // hello
        }
    }
    ```

## 表单和 v-model

1. `v-model` 用于在表单类元素上双向绑定，比如 `input`,`textarea` 等

    `<textarea cols="30" rows="10" v-model='msg'>我是多行文本的初始化值</textarea>
    ` 

    绑定了 `v-model` 会忽略 `textarea` 的默认值

2. 单选框

    单个单选框用 `v-bind` 绑定属性(v-model 不生效)

    多个单选框用 `v-model` 和 value 配合使用

3. 复选框

    单个复选框：用 `v-bind` 和 `v-model` 绑定都可以

    多个复选框：用 `v-model` 和 value 配合使用。当 `v-model` 的初始值是字符串的时候，选中后绑定值会变成 true,如果初始值是数组，选中后绑定值会增加对应的 value

4. 下拉框

    单选下拉框：用 `v-model` 双向绑定时，初始化可以是字符串也可以是数组，选中后绑定值为对应的 value。

    多选下拉框：用 `v-model` 双向绑定时，初始化可以是字符串也可以是数组，选中后绑定值对对应的 value 或者 value 的数组.

总结：

1. 单个 radio 用 `v-bind`，`v-model` 是不生效的
2. 多选时（checkbox, select)，`v-model` 最好初始化为数组
3. 单选 `v-model` 最好初始化为字符串

动态绑定：

1. 用 `v-bind` 绑定值后，可以用 `v-model`获取绑定值(但是有必要吗？)
2. `true-value` 和 `false-value` 动态绑定不同的值
3. 在 select 标签上绑定 `value` 属性对 `option` 没有影响

修饰符:
1. v-model.lazy 

    失去焦点或者敲回车之后改变`v-model`的值(默认的是`input`事件实时更新)

2. v-model.number

    自动将可转换的 `string` 变为 `number`

2. v-model.trim

    去掉首尾空格
    
## 组件

1. 组件的注册和挂载
	
	- 全局注册组件

		```
		Vue.component('my-component',{
			template: '<div>组件</div>'
		})
		<div id='app'>
			<my-component></my-component>
		</div>
		```

		优点：所有的 `vue` 实例都可以使用.

		缺点：权限太大，容错率降低。

	- 局部注册组件

		```
		var app = new Vue({
			el: '#app',
			components: {
				'app-component': {
					template: '<div>app内局部注册的组件</div>'
				}
			}
		})
		```

	- `is`属性挂载组件
	
		组件的使用会受到`html`标签的限制，比如 `<table>`标签内只能有`<tr>``<td>`,所以直接在`<table>`中挂载组件没有用。这时可以用`is`属性来挂载组件.

		```
		<table>
			<tbody is='my-component'>
		</table>
		```

	- 组件的注意事项

		1. 命名必须小写加横线（xxx,xxx-component)

		2. template 的内容必须被一个 DOM 元素包裹

		3. 除了 template 外，可以定义组件的其他属性（data, methods, computed)

		4. data 必须是一个方法(函数)



